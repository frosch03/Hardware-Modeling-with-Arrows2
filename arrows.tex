%\documentclass[11pt,final,a4paper,leqno]{article}
\documentclass[11pt,final,a4paper]{article}
\usepackage[ngerman,english]{babel}
%\usepackage{ucs}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{textcomp}
\usepackage{setspace}
%\usepackage{MnSymbol}
\usepackage{amsmath} % flush eqations to the left

\lstnewenvironment{haskell}[1][]{
  \lstset{
    fancyvrb=true, columns=flexible, language=haskell,
    captionpos=b,
    basicstyle=\ttfamily\small\setstretch{1},
    commentstyle=\color{ggray}\slshape,
    upquote=true,
    escapechar={@},
    emph={True,False}, emphstyle=\color{green},
    literate=*{...}{{\textcolor{ggray}{...}}}{3}%
             {\{}{{\textcolor{blue}{\{}}}{1}%
             {\}}{{\textcolor{blue}{\}}}}{1}%
             {->}{{$\rightarrow$}}{4},
    stringstyle=\color{red}, showstringspaces=false,
    keywordstyle=\color{blue},#1
}}{}


% Commands
\newcommand{\hs}[1]{%
  \lstinline[
    fancyvrb=true, columns=flexible, language=haskell,
    captionpos=b,
    basicstyle=\ttfamily\setstretch{1},
    commentstyle=\color{ggray}\slshape,
    upquote=true,
    escapechar={@},
    emph={True,False}, emphstyle=\color{green},
    literate=*{...}{{\textcolor{ggray}{...}}}{3}%
             {\{}{{\textcolor{blue}{\{}}}{1}%
             {\}}{{\textcolor{blue}{\}}}}{1}%
             {->}{{$\rightarrow$ }}{2},
    stringstyle=\color{red}, showstringspaces=false,
    keywordstyle=\color{blue}]!#1!%
}
\newcommand{\grafik}[4][0.9]{%        % Bild einfügen, [Skalierung], {Dateiname ohne Endung}, {Beschriftung}, {label zum Referenzieren}
    \begin{figure}[ht]%               % before: htbp 
        \begin{center}
            \includegraphics[width=#1\columnwidth]{Images/#2}
            \caption{\label{#4} #3}
            
        \end{center}
    \end{figure}
}
\newcommand{\xfig}[4][0.9] {%      %xfig figure einfügen, [Skalierung], {Dateiname ohne Endung}, {Beschriftung}, {label}
    \begin{figure}[ht]
        \begin{center}
            \graphicspath{{./}{Images/}}
            \scalebox{#1}{%
                \input{Images/#2}
            }
            \caption{\label{#4} #3}
        \end{center}
    \end{figure}
}
\newcommand{\reFLect}{\textit{re\kern-0.07em F\kern-0.07emL\kern-0.29em\raisebox{0.56ex}{ect}}}
\newcommand{\boxit}[1]{\mbox{{\it #1}}}

% Colors
\definecolor{gray}{gray}{0.5}
\definecolor{ggray}{gray}{0.7}
\definecolor{green}{rgb}{0,0.5,0}
\definecolor{textgray}{gray}{0.25}
\definecolor{backgray}{gray}{0.95}


\title{Hardware Design with Functional Datastructures: Functions, Arrows, Tupels, Vectors, and Inspection} 

\begin{document}

\section{Introduction}

\section{Hardware Modeling in the Functional Programming Paradigm: Recent Approaches}
\label{recent_approaches}
% TODO : Is stated in intro? 
As stated in the introduction, modeling hardware in functional languages is old news, there have been various approaches in the
past. The beginning dates back to the early 80s where a group around Mary Sheeran came up with a functional HDL (Hardware
Description Language) muFP\cite{sheeran:muFP}. In the same decade John O'Donnell presented his functional HDL
HDRE\cite{hydra:old,donnell}. These two HDL's gave birth to numerous later approaches that are base more or less on them.

One of Sheeran's students, Coen Claessen, later came up with a monadic solution called Lava\cite{claessen:hardware}. Ingo Sanders
et al introduced an approach, ForSyDe \cite{forsyde:phd,forsyde:ieee} that is based on meta programming techniques. Lava, ForSyDe
and also Hydra %TODO : Hydra reference in literature
represent HDL's embedded around the functional programming language Haskell; MyHDL \cite{myhdl} is embedded in the functional
flavored interpreter language Python. There is HML\cite{hml}, a simple HDL which is embedded inside ML, another functional
programming language.

Than there are functional languages that are exclusively designed to describe hardware, like the language SAFL (=Statically
Allocated Functional Language)\cite{sharp,sharp:flash,sharp:codesign}. This one compiles direct into a netlist; it does not
support dynamic allocated storage like heaps or stacks since these kind of software features do not map well on silicone.

Another candidate for the functional meta programming languages section is the language \reFLect \cite{reflect}. It's one that is
developed at Intel and tailored for hardware design and theorem proving.

There are good reasons why meta programming (also called \emph{reflexivity}) is beneficial for the use as HDLs. Meta programming
allows a program to have a representation of itself, usually by providing data structure of the abstract syntax tree. With this
tool at hand the developer is able to \emph{compute} parts of their program rather than \emph{write}them. This leads to a direct
and natural implementation of program transformations. Haskell also allows to meta programming through a library called ``Template
Haskell''\cite{haskell:template}. 
% TODO : Warum werden Haskells Meta-Programming fähigkeiten stifmütterlich behandelt? 

With cryptol\cite{cryptol:programming} another class of functional HDLs enters the scene. While all the other HDL's are general
purpose, cryptol is designed to model cryptographic hardware. A sub-language of cryptol is designed by Galois, explicit to generate
FPGA implementations \cite{cryptol:fpga}. Cryptol has lately been adopted by an American agency and isn't public developed
anymore.

\section{Arrows for Hardware development}
% TODO : Cite: Generalizing Monads to arrows
Arrows are lately developed concept in functional programming. They are best described in short as generalized Monads. Arrows
enable a data flow view onto problems. This fits the hardware developers view which has always been a data flow view, as in
circuit board layouts or in state flow diagrams. The arrow \emph{proc}-notation also transports the data flow view into the
source. %TODO: cite ross patterson
Its easy to generate netlists out of arrows, which basically boils down to a pretty print function. This also holds for the
generation of typical HDL code like VHDL. They can be used to simulate behavior or proof properties of the circuit. This section
gives a brief overview of the \hs{Grid}-Arrow that can be used to generate VHDL code or to simulate a circuit.

\subsection{Grid-Arrow}
The \hs{Grid}-Arrow is a combination of an executable arrow and a descriptive hardware component part. In a first approach one can
imagine the descriptive part to live inside the arrow. But that does not work out, so they are stored equal to each other inside a
tuple. The arrow resides in the first, the graph occupies the second part of the tuple.
\begin{haskell}
  newtype Grid a b c = GR (a b c, CircuitDescriptor)
\end{haskell} 
Alongside with the arrow execution, the generated Netlist is stored inside the graph like data structure called a
\hs{CircuitDescriptor}.  The name Grid is analog chosen to the snap circuit toys from childhood, where one also could combine
hardware elements arbitrary. The Grid type is a surface where hardware elements can be combined with each other to compose new
structures and analyze them. But it is not only the surface to combine hardware components, it's also a recursive surface. So it
is used as hardware component itself which means a \hs{Grid} is an arrow on its own.


\subsection{Circuit-Descriptor}
The descriptive part of the arrow is called a \hs{CircuitDescriptor}. Something of type \hs{CircuitDescriptor}, like the name
suggests, describes a circuit in detail. The combination sequence of the hardware parts, the pin layout, their cabling structure
and also recursively all subcomponents are represented inside the \hs{CircuitDescriptor}. A circuit with such a descriptor has
enough detail to be expressed as a Netlist.

\par
The actual data type is divided into three\footnote{actually four, because the empty descriptor requires it's own} unique
descriptors:
\begin{itemize}
\item \emph{Combinatorial:} are the parts of a circuit that are describable without a clock or buffered data. For example all
  Boolean logic gates fall into this category.
\item \emph{Register:} A register is used to describe the storage of data on the one hand and is used to clock computations on the
  other hand. The implementation of a register highly depends on the target platform. There is no need to know it's details at
  this point.
\item \emph{Loop:} Those Hardware components that are referring onto them self are handled in the looping section.
\end{itemize}

\begin{haskell}
  data CircuitDescriptor
    = MkCombinatorial
      { nodeDesc :: NodeDescriptor
      , nodes    :: [CircuitDescriptor]
      , edges    :: [Edge]
      , cycles   :: Tick
      , space    :: Area
      }
    | MkRegister
      { nodeDesc :: NodeDescriptor
      , bit      :: Int
      }
    | MkLoop
      { nodeDesc :: NodeDescriptor
      , nodes    :: [CircuitDescriptor]
      , edges    :: [Edge]
      , cycles   :: Tick
      , space    :: Area
      }
    | NoDescriptor
    deriving (Eq)
  type Netlist = CircuitDescriptor
\end{haskell} 

The \hs{MkCombinatorial} and the \hs{MkLoop} parts reveal a classic functional graph structure that is build from two lists. One
containing the edges (\hs{edges :: [Edge]}) and the other containing the nodes (\hs{nodes :: [CircuitDescriptor]}).  Additionally
there are information that are equal for every circuit and are stored inside the (\hs{nodeDesc :: NodeDescriptor}) with the graph. At last, information about the hardware's performance (space and time) is stored alongside with the graph.
\begin{haskell}
  data NodeDescriptor
    = MkNode
      { label   :: String 
      , nodeId  :: ID
      , sinks   :: Pins
      , sources :: Pins
      }
    deriving (Eq)
\end{haskell} 
% Each node itself is a \hs{CircuitDescriptor} and contains a list of \hs{CircuitDescriptor}s, so each node could be described
% recursively, which suits hardware very well.

A general problem with such data structures is, they do describe a graph but they don't enforce to build a correct one. In such
cases it's common to supply \hs{smart constructor}s along with the data type. These constructors are functions that take all the
elements the actual \hs{CircuitDescriptor} exists of. Than they check the inputs against given constraints and only generate the
output if the input fulfills them. In that way it's assured that only valid hardware components are constructed.

\par
For example the combinatorial section only accepts non looping connections. A wire is a connection between two \hs{Pins} of one or
two hardware components. The output pin is called the source and the input pin is called the sink of a component. Our approach enforces that every component on a Grid is wired up. 
\begin{haskell}
  type Anchor       = (Maybe CompID, PinID)
\end{haskell}
The outer most grid can't be wired up as it represents a not yet placed piece of hardware. This is mirrored by the \hs{Maybe
  CompID} in the type of an anchor. \xfig[.9]{ic-pin.pspdftex}{Image of IC {\tiny (by Sergei Frolov)}}{img:ic-with-pin}

\subsection{Lists through Tuples}
The Haskell arrow interface is build upon tuples and therefore prefers them. Circuits come often with a list like interface so we
model them with tuples. There are operators, like binary logic operators, that perfectly match the tuple structure. In example,
component $C_0$ produces the outputs $s_0, s_1, s_2, s_3$. Another component $C_1$ processes $s_0$ and $s_2$; $C_2$ acts on $s_1$
and $s_3$. The process of restructuring the output of one function into an input to another function is called retuple'ing because
it is only possible to change the way data is tupled into each other. As example a function that does such tuple'ing is \hs{mvRight}. This one takes an argument of the structure \((x,(y,z))\) to a different structure \((y,(x,z))\).

\begin{haskell}
mvRight :: (Arrow a) => Grid a (my, (b, rst)) (b, (my, rst))
mvRight           -- aFloatR
  =   aDistr      -- aDistr : is that really aDistr?
  >>> first aSnd
\end{haskell} 

There are two arrows involved here, \hs{aDistr} and \hs{aSnd}. With \hs{aDistr} the first element is distributed over the second
one and with \hs{first aSnd} the first occurrence is dropped. The \hs{mvRight} arrow floats the first element one position to the
right. Of curse this arrow assumes a structure where always the first element of a tuple is a value, the second is another tuple:
\((v_1, (v_2, (v_3, (v_4, v_5, (\dots)))))\)

\par
A common task over the list like tuples is to apply an arrow to the front and than concentrate the remaining calculation on the
remaining inner structure. For this purpose the operator \hs{>:>} helps to clarify the code that describes such computations.
\begin{haskell}
  aA >:> aB = aA >>> (second aB)
\end{haskell} 

The operator \hs{>:>} is based on the \hs{>>>} operator with a difference. The first supplied arrow is executed over the whole
input data tuple, while the second one is applied only to the second part of the tuple. Such an operator comes handy as long list
like tuple structures are used and are processed from the left.

\par
While working with tuple lists, it is often needed to reorder the parenthesis around the data so that selector functions like
\hs{first} process the right data. The two arrows \hs{a\_xXX2XXs} and \hs{a\_XXx2xXX} exploit the associative law of arrows. The
cryptic names mirror the changing structure, upper case letters show the grouped position.
\begin{align*}
  \text{a\_xXX2XXx} &: (a, (b, c)) \rightarrow ((a, b), c) \\
  \text{a\_XXx2xXX} &: ((a, b), c) \rightarrow (a, (b, c))
\end{align*}



\section{First Approach: Classical Arrows}
Within this section we present a cycle redundancy check algorithm, implemented with the design method of arrows. Later on it's
shown how the netlist is generated. The section concludes with the problems of this arrow approach.

\subsection{CRC - Implementation}
A CRC - cycle redundancy check - is a method to calculate checksums of data. The calculation of a CRC is based upon a polynomial
division, where the reminder is the CRC. Our approach calculates the CRC with a functional galois type shift register.

\par
The shift register is modeled with a list type and the positions of the feedback. The list is simulated by tuples and therefore
the feedback value is feed back into the list with the \hs{mvRight} arrow.

\par
Different feedback positions are captured in multiple arrows called \hs{toInner$_n$}. 
%Different feedback positions are captured in multiple arrows called \hs{feedbackk$_n$}. 

\begin{haskell}
toInner5       -- feedback5
  =   mvRight
  >:> mvRight
  >:> mvRight
  >:> mvRight
  >:> aFlip
\end{haskell} 

% TODO : aCRC8
The principle behind a $n$-Bit CRC is captured in the arrow \hs{crc\_checksum\_8} 
\begin{haskell}
crc_checksum_8 crc_polynom polySkip padding start rest --------------------REVIEW
  =   (padding &&& aId)
  >>> toInner8

  >>> (start &&& rest)
  >>> first (crc_polynom)

  >>> step
  >>> step
  >>> step
  >>> step
  >>> step
  >>> step

  >>> aFlip
  >>> polySkip
  >>> crc_polynom

  where step =   a_xXX2XXx
             >>> first 
                 (   aFlip
                 >>> polySkip
                 >>> crc_polynom
                 )   
\end{haskell} 

The CRC calculation is preceeded by the alignment of the input data. Therefore the padding bits, that are $0$ for CRC calculation, are floated to the right end of the tuple list.
\[((p_0, p_1), (b_0, (b_1, (b_2, (b_3, b_4))))) \rightarrow (b_0, (b_1, (b_2, (b_3, (b_4, (p_0, p_1))))))\]

Afterwards the arrow abstracts the steps to calculate a CRC sum. The combined action \hs{(start &&& rest)} splits the input data
into the bits that fill the Galois shift register (the \hs{start} part) and the remaining bits (the \hs{rest} part). Keep in mind
that the \hs{&&&} operator first duplicates its input. The starting bits are then fed into the shift register via the \hs{first
  (crc\_polynom)}. Step by step all bits are consumed. The last step is executed without the need of a \hs{first} selector.
Therefore the arrow ends with a \hs{aFlip >>> polySkip >>> crc\_polynom} expression.


\subsection{Simple Example}
Every CRC-Code is equipped with a polynomial that especially fits the needs of the domain. In the example the CRC-Code for USB is
shown. The polynomial are:
\[
  \text{USB} : x^5 + x^2 + 1 
\]


The polynomial describe at which positions the input bit is \hs{xor}'ed with the bit that has traveled through the shift
register. For the USB CRC $\text{bit}_0$ and $\text{bit}_2$ are \hs{xor}'ed with $\text{bit}_5$.

\xfig[.5]{CRC-USB}{USB CRC}{fig:usb-crc}

To summarize this for the USB CRC, the highest exponent is $5$. This means, that:
% TODO : Namings toInner ... feedback usw. ... 
\begin{itemize}
  \item the \hs{polySkip} needs to be \hs{toInner5}
  \item there are $5$ \hs{padding} bits \hs{aConst (False, (False, (False, (False, False))))} 
  \item the split between \hs{start} and \hs{rest} is after bit $5$
\end{itemize}

This results in the definition of the USB CRC:
% \begin{haskell}
% crc_checksum_ccit_8 
%   :: Arrow a => Grid a 
%     (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, Bool))))))) 
%     (Bool, (Bool, (Bool, Bool)))
% crc_checksum_ccit_8
%   = crc_checksum_8   
%       crc_polynom_ccit
%       toInner4
%       (aConst (False, (False, (False, False))))
%       (second.second.second.second $ aFst)
%       (aSnd >>> aSnd >>> aSnd >>> aSnd >>> aSnd)
% \end{haskell} % $ to fix that syntax highlighting problem 


\subsection{Building Netlists}
The data type of the previous CRC function denotes a \hs{Grid} arrow. A graph is a different form of a Netlist. Hardware
components and Pins are identified integer id's.
\begin{haskell}
type CompID = Int
type PinID  = Int
\end{haskell}

\par
An edge represents a wire between two pins and is identified by an AnchorPoint, the tuple \hs{Just
  CompID}$\times$\hs{PinID}. Unconnected anchor points are the one that go into a component, called \hs{SinkAnchor} as well as one
that comes from a component, the \hs{SourceAnchor}. They do not have a \hs{CompID}, their tuple is
(\hs{Nothing}$\times$\hs{PinID}). This maps to the real world, where unplaced components have pins from and to nowhere.

\begin{haskell}
type AnchorPoint  = (Maybe CompID, PinID)
type SinkAnchor   = AnchorPoint
type SourceAnchor = AnchorPoint
\end{haskell}

A wire between two \hs{AncorPoint}s of two components is an edge between two Nodes of the netlist graph.  
\begin{haskell}
data Edge 
  = MkEdge { sourceInfo :: SourceAnchor
           , sinkInfo   :: SinkAnchor }
\end{haskell}
 
A node holds the information about the component. The name is used in the Netlist generator to identify entities. Each node holds
a list of sub nodes that represent the recursive structure form which the node is assembled. They also hold the list of connected
edges, as well as the list of in- and output pins.

\begin{haskell}
data StructGraph
  = MkSG { name    :: String
         , compID  :: CompID
         , nodes   :: [StructGraph]
         , edges   :: [Edge]
         , sinks   :: Pins
         , sources :: Pins }   
\end{haskell}


\subsection{Drawbacks}
This approach has two problems, that are visible in the CRC example. All input data of these hardware components must fit into
tuples. Simple logic gates fit well into this scheme. For hardware components with more than two pins data structures like lists
are needed. It can be simulated with tuples as it is done in the above CRC example. But the simulation comes at a cost.  A big
part of the code is needed only for restructuring the tuples. This process becomes tedious, confusing and error prone, if bigger
real world hardware components are be modeled. Think about 32 or even 64-Bit ALU's

\par
The tedious tuple code could be avoided by the use of Patterson's proc-notation for
arrows\cite{PatersonNewNotation}.  The proc-notation abstracts the tuple code and the hardware can be described more
``visually'' in the source. But it's just syntactic sugar, underneath there are still tuples in use.  The
following code shows how the USB CRC can be modeled with the proc-notation:
\begin{haskell}
------------------------------------------------ REVIEW wrong function
crc_polynom_ccit 
 = proc (b4, (b3, (b2, (b1, b0)))) -> do
     b4' <- aId  -< (b3)
     b3' <- aId  -< (b2)
     b2' <- aXor -< (b4, b1)
     b1' <- aXor -< (b4, b0)
     returnA     -< (b4', (b3', (b2', b1')))
\end{haskell} 

\par
The second problem affects the notation that comes from the auto generated arrow code. Patterson's notation heavily uses the
\hs{arr} function. Because it is possible to ``lift'' any function passed to \hs{arr} into an arrow, it is impossible to keep
track of the type of that function. The type information of the passed function is needed to generate a proper component. These
information like the pin count are codified in the type of the lifted function. This makes it possible to generate component
arrows ad-hoc. Nonetheless a proper name to that function is missing in every case.


\section{Coping with the Tupel-Problem - ``Vector-Arrows''}
Arrows match hardware pretty good if it is binary in their in- and output. In this section we show how to overcome the problems with $n$-ary ($n > 2$) hardware components. 

% TODO : wo passt dieser satz? 
% So arrows are an adequate abstract form to describe hardware, they are modular and they come with an enhanced type system that
% helps to reduce errors. The part which does not match the hardware perfect is the way the in- and output pins are structured,
% the tuples.

\par
The reason for the arrows preference of binary circuits are the underlying tuples. And also the tuples allow the in- and output to
be of any kind. In the digital world, hardware transmits nearly always boolean values. Integers are transmitted via bundled
boolean values. The developers of Sensors try to digitize pretty early in their design process. \cite{MakinwaSmartSensor}

\par
Therefore the type \hs{a b c} is too general for a logic gate: the type of the in going data should match the type of the out
coming values. Secondly, a set of wires is not a tuple and for instance, the tuple \hs{(a,(b,(c,d)))} represents the same set of
wires as the tuple \hs{(a,((b,c),d))}. The number of possible -- different with respect to syntax and type -- representations of a
set of wires exponentially explodes with a growing number of wires that we are trying to model.

\par
These properties constrain hardware to be static in their type of values and dynamic in their amount of values. Arrows in contrast
are dynamic in the type of values but are static in their amount of the values. So arrows are opposing the hardware's nature
here. It is possible to transform arrows so that they match hardware more naturally, without loosing the beneficial properties for
hardware design.

\par
A vector fulfills the desired hardware behavior. The vector $Vec_n^b$ is a vector of $n$ values over the type $b$. In the
following we sketch different ways to express such ``Vector-Arrows'' present different approaches. 

\begin{haskell}
------------------------------------------------REVIEW only one example ? 
class VArrow a where
  arr     :: ((@$Vec_n^{b}$@)-> (@$Vec_m^{b}$@)) -> a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@)
  firsts  :: a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@) -> a (@$Vec_{(n:+k)}^{b}$@) (@$Vec_{(m:+k)}^{b}$@)
  seconds :: a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@) -> a (@$Vec_{(k:+n)}^{b}$@) (@$Vec_{(k:+m)}^{b}$@)
  (>^>)   :: a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@) -> a (@$Vec_m^{b}$@) (@$Vec_k^{b}$@) -> a (@$Vec_n^{b}$@) (@$Vec_k^{b}$@)
  (&^&)   :: a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@) -> a (@$Vec_n^{b}$@) (@$Vec_k^{b}$@) -> a (@$Vec_n^{b}$@) (@$Vec_{(m:+k)}^{b}$@)
  (*^*)   :: a (@$Vec_n^{b}$@) (@$Vec_m^{b}$@) -> a (@$Vec_k^{b}$@) (@$Vec_j^{b}$@) -> a (@$Vec_{(n:+k)}^{b}$@) (@$Vec_{(m:+j)}^{b}$@)
\end{haskell}


\subsection{Horn-like-clause Solution}
As vectors are not a purely functional data structure the first approach would be to define a list data type that is limited in
length. It is necessary to introduce a counter, into the data type. We choose type level natural numbers to restrict the list in
length.
% TODO, cite richtig platzieren
\cite{kiselyov:strong_collections}
\begin{haskell}
data Vec n a where
  T    :: Vec 'VZero a                           -- (@$Vec_0^a$@)
  (:.) :: a -> Vec n a -> Vec ('VSucc n) a -- (@$a \rightarrow Vec_n^a \rightarrow Vec_{n+1}^a$@)
\end{haskell} 

The type level natural numbers are introduced as peano numbers. This is similar to the mechanism shown by Kiselyov et al
\cite{kiselyov:strong_collections}.

\par
The arrow class functions \hs{arr}, \hs{first}, \hs{second}, \hs{(***)} and \hs{(&&&)} are translated into their vectorised
versions. \hs{arr} takes a Haskell function into an arrow that expects a vector of $n$ $b$'s ($Vec_n^b$) into a new vector of
$b$'s of length $m$ ($Vec_m^b$). The sequential concatenation of arrows is done by the \hs{(>^>)} operator.\hs{first} translates
an arrow into another one, that takes it's input from the front element of a tuple. \hs{second} does the same thing, but with the
second element of that tuple. So these two functions are uniquely based upon the tuple. With vector arrows there are no tuples,
and therefore there is no way to differentiate a first value from a second one.

\par
As Haskell is statically typed, everything in the data type is declared. Therefore all variables that hold type level natural
numbers must be defined in the data type context. If type level integers are added, a type class \hs{VAdd} is listed in the type
context. Working with such contexts reminds of Prolog's Horn Clauses programming style. Combined the arrow class for vector arrows
looks like the following:

\begin{haskell}
  class (Category a) => VArrow a where
    arr    :: (VNat n)  
           => (Vec n b -> Vec n b) -> a (Vec n b) (Vec n b)


    init   :: ( VNat n, VNat m
              , VAdd n m nm
              , VEq (VSucc n) nm VTrue
              )   
           => a (Vec n b) (Vec m b) -> (Vec nm b) (Vec nm b) -> a (Vec n b) (Vec n b)

    tail   :: ( VNat n, VNat m
              , VAdd n m nm
              , VEq nm (VSucc m) VTrue
              )   
           => a (Vec nm b) (Vec nm b) -> a (Vec m b) (Vec m b)

    tail'  :: ( VNat m ) 
           => a (Vec (VSucc m) b) (Vec (VSucc m) b) -> a (Vec m b) (Vec m b)

    head   :: ( VNat n, VNat m
              , VAdd n m nm
              , VEq nm (VSucc m) VTrue
              )   
           => a (Vec nm b) (Vec nm b) -> a (Vec n b) (Vec n b)

    last   :: ( VNat n, VNat m
              , VAdd n m nm
              , VEq (VSucc n) nm VTrue
              )   
           => a (Vec nm b) (Vec nm b) -> a (Vec m b) (Vec m b)


    (***)  :: (VNat n, VNat m, VAdd n m nm) 
           => a (Vec n b) (Vec n b) -> a (Vec m b) (Vec m b) -> a (Vec nm b) (Vec nm b)

    (&&&)  :: (VNat n, VAdd n n nn) 
           => a (Vec n b) (Vec n b) -> a (Vec n b) (Vec n b) -> a (Vec n b) (Vec nn b)
\end{haskell}

\par
The classic arrow class gives a default definition for the \hs{(***)} operator. \hs{(***)} is defined via \hs{first} and
\hs{second}. With the Horn's like arrow class there is nothing like a \hs{second} arrow and therefore it's not possible to define
\hs{(***)} in the standard way. The problem rises with an inability to define a correct split function. 

\par
It is possible to divide the list just at the ``right spot'', once an arrow is known. \hs{first f} splits the input
into one with exact the length that \hs{f} expects as input, and a rest vector. So with \hs{aXor} being an arrow that takes two
Booleans to one, \hs{first} applied to \hs{aXor} must be an arrow from at least two Booleans to at least one.
\begin{haskell}
  --      a (Vec 2 Bool) (Vec 1 Bool)
  aXor :: a (Vec (VSucc (VSucc VZero)) Bool) (Vec (VSucc VZero) Bool)

  --              a (Vec 2+k Bool) (Vec 1+k Bool)
  first (aXor) :: (VNat k, VAdd (VSucc (VSucc VZero)) k nk, VAdd (VSucc VZero) k mk)
               => a (Vec ((VSucc (VSucc VZero)) + k) Bool) (Vec ((VSucc VZero) + k) Bool
\end{haskell} 
$2+k$ is the length of the input vector. The output is a vector of length $1+k$. This unsugared syntax actually is a major
drawback.  It is not possible to write $2+k$ instead one needs to add \hs{VAdd (VSucc (VSucc VZero)) k nk} as context to the data
type. This might be tedious for easy arrows, it becomes an error source for larger ones.


\subsection{Type-Family Solutions}
The next approach is to replace the Horn like clauses by actual calculations. Haskell has lately come up with a type family
extension that comes in handy for this task.

\par
A type family in a way enables to calculate the type constructor of a data type. A feature the horn-clause solution lacks. The
length of the vector is stored in a peano number. As peano numbers are expressed as a bunch of type constructors, type families
are used to calculate the constructor amount. The Haskell-Wiki describes this vividly: A type family is to a data type, what the
method of a type class is to a function. As the earlier solution showed, the addition is one operator that is needed.

\begin{haskell}
type family (n::VNat)   :+ (m::VNat) :: VNat
type instance VZero     :+ m     = m 
type instance VSucc n   :+ m     = VSucc (n :+ m)
\end{haskell}

The first Line defines the type family. The operator \hs{:+} needs to operate on peano numbers. The following two lines define the
addition function in a straight forward way.

\par
With the addition type family the arrow could be defined more similar to the original type class.
\begin{haskell}
class Category a => VArrow a where
  arr     :: (Vec n b -> Vec m b)
          -> a (Vec n b)         (Vec m b)

  firsts  :: a (Vec n b)         (Vec m b)
          -> a (Vec (n :+ k) b)  (Vec (m :+ k) b)

  seconds :: ((m :+ k) ~ (k :+ m))
          => a (Vec n b)         (Vec m b)
          -> a (Vec (k :+ n) b)  (Vec (k :+ m) b)

  (***)   :: a (Vec n  b)        (Vec m  b)
          -> a (Vec n' b)        (Vec m' b)
          -> a (Vec (n :+ n') b) (Vec (m :+ m') b)

  (&&&)   :: a (Vec n b)         (Vec m  b)
          -> a (Vec n b)         (Vec m' b)
          -> a (Vec n b)         (Vec (m :+ m') b)
\end{haskell}

\par 
The problem with this approach is the compiler. It is not possible for GHC to deduce arithmetics in the type context. This is also
valid for simpler calculations down to even the equality of $n+m = m+n$. It's possible to supply the compiler with these
information by hand. But this are only hints into a direction. At this point it gets tedious to supply hints for easy deductions
and gets unpractical for complicated arithmetic's.


\subsection{Dependently-Typed Solution}
A dependently typed programming language is a language, that mixes expressions with types. It therefore allows the calculate of
types within that same language. 

\par
In summary the previous solutions all try to fix a unitary problem. And this problem depends on the fact that vectors aren't a
purely functional data structure. A vectors length must show up in it's data type so that a function can match against it.

\par
The transfer of tuple arrows to vector arrows changes the inner data type of arrows. Therefore the projection maps from the inner
data type must translate to the vector version. \hs{first} and \hs{second} exactly match the tuple projection maps in Haskell,
namely \hs{fst} and \hs{snd}.

\par 
With vectors the \hs{first} statement is straight forward defined. The \hs{second} expression is the head-scratcher.  The
implementation of \hs{first} constraints it's inputs to only those, that are equal or larger than the ones \hs{f} expects. The
\hs{second} case adds the right alignment on top. This can be achieved by calculating the size of the sub vector, ignoring him and
applying the function to the reminder. It can also be done via reversing the vector multiple times and than applying the function
to the front of the vector.

\par
This makes it obvious, that the naming (\hs{first} and \hs{second}) for vectors is at least counter intuitive. For example an
\hs{second aSwitch} arrow applied to a vector $(1, 2, 3, 4, 5)$ evaluates to $(1, 2, 3, 5, 4)$. We propose a more accurate name to
the \hs{second} statement for vector arrows, namely \hs{last}.

\par 
While \hs{aSwitch} is of type $Vec_n^{Int}$, the expression \hs{last aSwitch} must be of type $Vec_{k+n}^{Int}, k \ge 0$. This is
hard to express in a functional language, in a dependently typed language this is expressible by the data type.

\par
There are multiple languages with dependent types out there. The one with a pretty good connection to Haskell is Agda. The
following describes the arrow class in a functional language with dependent types.


\begin{haskell}
record VArrow (_~~>_ : Set -> Set → Set) : Set₁ where 
  field
    arr    : forall {B n m}     -> (Vec B n -> Vec B m) -> (Vec B n) ~~> (Vec B m)
    firsts : forall {B n m k}   -> Vec B n ~~> Vec B m -> Vec B (n + k) ~~> Vec B (m + k)    
    lasts  : forall {B n m k}   -> Vec B n ~~> Vec B m -> Vec B (n + k) ~~> Vec B (m + k) 
    _>>>_  : forall {B n m k}   -> Vec B n ~~> Vec B m -> Vec B m ~~> Vec B k -> Vec B n ~~> Vec B k
    _***_  : forall {B n m k j} -> Vec B n ~~> Vec B m -> Vec B k ~~> Vec B j -> Vec B (n + k) ~~> Vec B (m + j)
    _&&&_  : forall {B n m k}   -> Vec B n ~~> Vec B m -> Vec B n ~~> Vec B k -> Vec B n ~~> Vec B (m + k) 
  infixr 2 _>>>_
  infixr 2 _***_
  infixr 2 _&&&_
\end{haskell}

\begin{itemize}
\item 
  \begin{itemize}
  \item tuple arrows => kartesische produkt kategorien
  \item vector arrows => produkt familien kategorien 
  \end{itemize}

\item problems with agda / dependent typed solutions 
  \begin{itemize}
  \item ebenfalls last lässt sich nicht sauber definieren / Gründe??? 
  \end{itemize}
\end{itemize}

\subsection{Vector-Arrows are not Arrows}
-  :+: and :-:
- \ldots

Conclusion: That is dependent typing and Haskell is not (yet) a dependently typed function programming language. And all in all it
seems that the Vec-Type together with the Arrows-Instances is too much dependent typing for Haskell


\section{Copeing with \hs{arr}-Problem}

\subsection{ForSyDe: Using the AST of the arr argument}
In order to transform a usual Haskell function into an hardware block, ForSyDe stores the AST of that function which is used later
to synthesis VHDL.  \

\subsection{Show-Type-Class (or Typeable)}


\subsection{Generalized Arrows -- avoiding arr}




\bibliographystyle{plain}
\bibliography{Bibliography}
\end{document}
