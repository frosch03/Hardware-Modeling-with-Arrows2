\documentclass[9pt,final,a4paper,leqno]{article}
\usepackage[ngerman,english]{babel}
\usepackage{ucs}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{MnSymbol}
\usepackage{amsmath} % flush eqations to the left
%\usepackage{amssymb}
%\usepackage{mathtools}

%\input{haskellstyle}

\lstnewenvironment{haskell}{%
  \lstset{}% 
  \csname lst@SetFirstLabel\endcsname
}
{%
  \csname lst@SaveFirstLabel\endcsname
}

\lstset {
  basicstyle=\small\ttfamily,
  flexiblecolumns = false,
  basewidth = {0.5em, 0.45em},
  literate = {+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
             {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
             {\\\\}{{\char`\\\char`\\}}1
             {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
             {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 
             {\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
             {>>}{{>>}}2 {>>=}{{>>=}}2
             {|}{{$\mid$}}1
             {<<<}{{$\lll$}}2 {>>>}{{$\ggg$}}2 {-<}{{$\leftY$}}1
}
%\lstset{                                % Definition der Sprache, f?r lstListings 
%        language=Haskell,               % Name der Sprache
%        breaklines=true,                % Sollen zu lange Zeilen umgebrochen werden?
%        captionpos=b,                   % Wo soll die Beschriftung stehen? (b - bottom, t - top)
%        tabsize=2,                      % Wie viele Zeichen springt ein Tab?
%        basicstyle=\small,              % Welche Schriftgr??e soll verwendet werden?
%        morekeywords={},    		% W?rter die als Schl?sselw?rter fett gedruckt werden sollen
%        deletekeywords={} 		% W?rter die nicht als Schl?sselw?rter fett gedruckt werden sollen
%}

\title{Hardware Modeling with Functional Datastructures: Functions, Arrows, Tupels, Vectors, and Inspection} 

\definecolor{textgray}{gray}{0.25}
\definecolor{backgray}{gray}{0.95}

\newcommand{\grafik}[4][0.9]{%        % Bild einfügen, [Skalierung], {Dateiname ohne Endung}, {Beschriftung}, {label zum Referenzieren}
    \begin{figure}[ht]%               % before: htbp 
        \begin{center}
            \includegraphics[width=#1\columnwidth]{Images/#2}
            \caption{\label{#4} #3}
            
        \end{center}
    \end{figure}
}

\newcommand{\xfig}[4][0.9] {%      %xfig figure einfügen, [Skalierung], {Dateiname ohne Endung}, {Beschriftung}, {label}
    \begin{figure}[ht]
        \begin{center}
            \graphicspath{{./}{Images/}}
            \scalebox{#1}{%
                \input{Images/#2}
            }
            \caption{\label{#4} #3}
        \end{center}
    \end{figure}
}

\newcommand{\reFLect}{\textit{re\kern-0.07em F\kern-0.07emL\kern-0.29em\raisebox{0.56ex}{ect}}}

\newcommand{\boxit}[1]{\mbox{{\it #1}}}

\newcommand{\hs}[1]{\mbox{\lstinline[basicstyle=\color{textgray}]!#1!}}
\newcommand{\hsLine}[1]{$$\mbox{\tt{#1}}$$}


\begin{document}

\section{Introduction}
\label{introduction}
With the rise of rapid prototyping and development methodologies in the hardware community, hardware has started to get softer. FPGA's are a
major contributor for this trend. It is only natural to take benefits out of the existing software engineering concepts. This can be seen in
hardware description languages like VHDL or Verilog. Both have taken their syntax from common languages like C and ADA\@. Those two are
typical imperative languages, but there are arguments that declarative languages fit more natural to the problem of hardware modeling.
Functional programming languages like \emph{Haskell} are declarative.

\begin{itemize}
  \item \emph{Referential transference}: While imperative languages force the programmer to prescribe the control flow a declarative
    language is stateless. Stateless means, that the programmer does not describe the control flow, but the compiler is able to decide the
    order of execution. Therefore concurrency isn't something that needs to be simulated (like it's done in System-C) but fits natural in
    the language and the developed code.
  \item \emph{Composition}: Functional programs are build out of the composition of small pieces. Again this attributes to hardware design
    where complex systems are also build out of the composition of smaller pieces.
  \item \emph{Type systems}: Functional languages like Haskell come with an expressive type system which helps to detect errors early and
    also helps the developer to a cleaner design.
  \item \emph{Higher-order functions}: Typical functional design techniques like higher order functions can be used to abstract common
    circuit structures, so that the developers task is to instantiate them in order to get circuits.
  \item \emph{Lazy evaluation}: With the help of lazy evaluating languages it is easy to express infinite data structures, which also maps
    natural to stream processing hardware specifications. 
\end{itemize}

This properties lead to some interesting development possibilities which are not new in the functional programming world, but are rather
unusual if not impossible in languages like VHDL\@. With the use of higher order functions developers are able to transform circuits just to
their needed behavior. The clean detachment of the languages semantics from the circuits specification is the key that leads to an extreme
flexible design. Last but not least the clear expressiveness of functional languages makes it easy to \emph{1:} reason, \emph{2:} realize
and \emph{3:} analyze functional programs. % TODO do i need to cite sheeran here?

\par
In fact, these are old news, functional programming pioneers pointed to the use of functional languages as perfect hardware design languages
long before. \cite{sheeran:perfect_match} %O'Donnell and all the others\ldots

\par
From the authors point of view it is not only natural to describe hardware with the help of functional programming languages, but also it is
the logical step.

\section{Hardware Modeling in Haskell: Recent Approaches}
\label{recent_approaches}
As stated in the introduction, modeling hardware in functional languages is old news, there have been various approaches in the past. The
beginning dates back into the early 80s where Mary Sheeran came up with a functional HDL muFP\cite{sheeran:muFP}. In the same decade John
O'Donnell presented his functional HDL HDRE\cite{hydra:old,donnell}. These two HDL's gave birth to numerous later approaches that are base
more or less on them. 

\par
One of Sheeran's students, Coen Claessen, came later up with a monadic solution called Lava\cite{claessen:hardware}. Ingo Sanders et al
introduced an approach, ForSyDe \cite{forsyde:phd,forsyde:ieee} that is based on meta programming techniques. Lava, ForSyDe and also Mydra %TODO : Hydra reference in literature
represent HDL's embedded into the functional programming language Haskell; MyHDL \cite{myhdl} is embedded in the functional flavored
interpreting language Python. There is HML\cite{hml}, a simple HDL which is embedded inside ML, another functional programming language. 

\par
Than there are functional languages that are exclusively designed to describe hardware, like the language SAFL (=Statically Allocated
Functional Language)\cite{sharp,sharp:flash,sharp:codesign}. This one compiles direct into a netlists; it does not support dynamic allocated
storage like heaps or stacks since these kind of software features do not map well on silicone. 

\par
Another candidate for the functional metaprogramming languages section is the language \reFLect \cite{reflect}. This one is developed at
Intel and tailored for hardware design and theorem proving. 

\par
There are good reasons why metaprogramming (also called \emph{reflexivity}) are beneficial for the use as HDLs. Metaprogramming allows a
program to have a representation of itself, usually by providing data structure of the abstract syntax tree. With this tool at hand the
developer is able to \emph{compute} parts of their program rather than \emph{write}them. This leads to a direct and natural implementation
of program transformations. Haskell also allows to metaprogramming through a library called ``Template Haskell''\cite{haskell:template}. 

\par
With cryptol\cite{cryptol:programming} another class of functional HDLs enters the scene. While all the other HDL's are general purpose,
cryptol is designed to model cryptographic hardware. A sublanguage of cryptol is designed by Galois, explicit to generate FPGA
implementations \cite{cryptol:fpga}. Cryptol has lately been adopted by an American agency and isn't public developed anymore.


\section{Why Arrows?}
In this section we give a short introduction to the concept of arrows; we compare them very brief to monads which are better known in the
functional community. We the show why arrows are a good way to describe hardware. 

\subsection{What are arrows}
The concept of a function is a pillar in functional programming and can't be compared to functions in imperative/procedural programming
languages. In languages of the latter kind, functions are seen as structuring elements that stuff imperative expressions together while also
make them available by a specific identifier, the function name. A function in the functional sense is oriented along the mathematical
definition of a function which is defined as the projection of input parameters to output values. If taken serious, this definition leads
to only deterministic behaving functions.  

\par
So the question is, how to express side effects (state changes like IO) with the use of deterministic functions. This dilemma can be solved
by making the state changes deterministic, which is done via a \emph{world parameter}. A function that takes such a world parameter than
is able to react on the world's state, can apply changes and could deliver it in the return value. With this trick it is possible to express
IO-, random or any side effecting function in a functional language. This world parameter could also be used to gain the control flow back,
such that a specific chain of functions, is executed in the given order. Because it is tedious to keep track of this world parameter, it is
captured inside a specific data structure, which then is called a Monad. With monads the developer is able to determine a specific control
flow. On one side this is better than no control flow but on the other side it is to specific to design parallel computations which are
usual found in hardware designs. 

\par
At this point, the concept of arrows comes to play, which represents the generalization of monads \cite{Hughes98generalisingmonads}. While
the monad is the abstract interface to the control flow of a function, the more general arrow states an abstract interface to all features
of a function.


\subsection{Arrows in the Hardware Design Process}
The similarity of functions on the one hand and hardware blocks on the other hand is well known and demonstrated in the functional
programming literature for the last decades \cite{sheeran:perfect_match,donnell}. While these similarities between those two are impressive,
there are also differences that need to be handled. Every approach that models hardware via functional functions has to face the fact, that
functional functions are extreme powerful. Functional concepts like higher-order functions, curried functions, etc\. doesn't map to silicon at
all. 

\par
We conclude that Haskell functions correlate to logic gates on the one hand and offer some incompatible features on the other hand. To
describe hardware components with functional languages, only a very specific subset of the features of a Haskell function can be mapped to
circuit design. Every functional solution tackles theses differences by some means or other. This gives rise to such a manifold solution
space as described in section~\ref{recent_approaches}. The approaches cope this problem via monads, avoidance of functional features or via
meta programming techniques. 

\par
As monads give the developer a handle to control the execution flow of functional programs, arrows offer a handle not only to the control
flow of functional functions, but to many more features of functions. In example, it is possible to specify the execution order but it is
not mandatory to do so. Such a behavior where parallelism is implicit, naturally fits to the behavior of silicone where parallelism also is
implicit. Another example is the ad-hoc creation of functions, so called lambdas in Haskell. The arrow interface provides a function that
can ``lift'' any other function into an arrow and so this mechanism can be used to specify lambda expressions inside arrows. As said
earlier, arrows provide handles to different building blocks of functional functions. Ad hoc creation of hardware blocks is something that
isn't possible and therefor is not used to model hardware. %% TODO : Kommt der unterschied zur vermeidung functionaler features hier raus?

\begin{itemize}
  \item Arrows compromise deep and shallow embedding, and seem to pick the benfits of both.a
  \item Arrows resemble premonoidal effect categories and\ldots   are a common way for category theorists to model the
  semantics of programming languages in a maximal generic way. In this view, arrows are executable maximum generic
  semantic specifications. With this genericity, one can hope to be able to do many things with such a specification:
  Execution, Synthesis, Proofing, (dependend on the concrete instance of the arrow)
  \item Interface (i.\,e. \hs{***}, \hs{&&&}, \hs{>>>}) is natural for combining hardware blocks
\end{itemize}

\par
Haskells type of a function that takes input of type $b$ to output of type $c$ is denoted as $b \rightarrow c$, with the $(\rightarrow)$
being a \emph{higher-order-type}. This higher order type takes two type arguments (namely $b$ and $c$) and yields a type as result (namely
the function type $(\rightarrow)\ b\ c$). $(\rightarrow)$ is just the prefix notation of the infix type operator $\rightarrow$. To take
control over the features of a function, the function type operator $\rightarrow$ needs to be replaced by something more general; a higher
order type variable $a$. This leads to the prefix written type:

\begin{center}
\begin{minipage}{.2\textwidth}
\begin{haskell}
a b c
\end{haskell}
\end{minipage} \end{center}

Because this is to general to be of any use, Haskells \emph{type classes} are used to specify the properties of that type variable $a$. This
type class is called \hs{Arrow}. 

\begin{haskell}
class Arrow a b c where 
  arr   :: (b -> c) -> a b c
  (>>>)  :: a b c    -> a c d   -> a b d
  first :: a b c    -> a (b, d) (c, d) 
  (***) :: a b c    -> a b' c' -> a (b, b') (c, c')
  (&&&) :: a b c    -> a b  c' -> a  b      (c, c')
\end{haskell}

In this type class a function \hs{arr} to lift ordinary functions into an arrow, the bind operator \hs{(>>>)}, as well as the combination
operator \hs{(***)} are defined. \hs{(&&&)} is just a special case of \hs{(***)}. 

\par
With the bind operator \hs{(>>>)} two arrows are combined into a new one and the specific arrows are executed in sequence from left to
right. This corresponds directly to sequencing circuit, where one gate computes first with it's outputs solder to the next gate. 
\par 
To model parallel computation the \hs{(***)}-operator is used. It take two different data flows ($b$ and $b'$), passes them into the first
and the second arrow. The results ($c$ and $c'$) are than combined and yielded as overall result. The \hs{(&&&)}-operator takes only one
input and provides it to both inner arrows.

\xfig[.6]{ArrowStarStarStar}{Schematic representation of ***}{figure:ststst}
\xfig[.6]{ArrowAndAndAnd}{Schematic representation of (\&\&\&)}{figure:ananan}

\par
Interestingly, this structure is at the same time the implementation of a lately developed concept in category theory, called Freyd~categories 
which are essentially premonoidal effect categories\cite{Heunen06arrows, Hughes98generalisingmonads,PatersonRA}. The term Freyd
category marks essentially a functor with another category in its domain. The important part is, that it specifies a category of
computations and therefore a mathematical definition for category theorists to model the semantics of programming languages. To have such a
direct connection to category theory helps to underly our approach with mathematical proof in the future. This also shows that the arrow
approach is a generic semantic for describing hardware systems. Also such a generic system not only can be used to model the hardware, but
also to synthesis, code generation, simulation or property proofing. 

\par
And there are more possibilities while using this approach. Another interesting arrow typeclass is the \hs{ArrowChoice} class. With a choice
arrow a model of different execution paths, depending on input parameters, could be expressed. This behavior is translated into Haskell's
\hs{Either} type and so it the result of type \hs{Either}. 

\begin{haskell}[]
class ArrowChoice a where
  (+++) :: a b c -> a b' c' -> Either (b b') (c c')
  (|||) :: a b c -> a b' c  -> Either (b b')  c 
\end{haskell}

Here again are two incarnations of that choice-operator. There is the \hs{(|||)}-operator, which combines two arrows with different input
types to an arrow of the same output type. Than there is the more abstract version, the \hs{(+++)}-operator which not only accepts two
different input types, but also returns two different output types.  

\xfig[.8]{ArrowPlPlPl}{Schematic representation of \hs{+++}}{figure:plplpl}
\xfig[.8]{ArrowPiPiPi}{Schematic representation of \hs{|||}}{figure:pipipi}

\par
For Hardware development interesting is also the \hs{ArrowLoop} typeclass that is able to express recursive circuits where the output value
is feed back into the arrow..
\begin{haskell}[]
class ArrowLoop a where
  loop :: a (b, d) (c, d) -> a b c
\end{haskell}

This one is essential for hardware development because there are considerable few circuits which go without recursion. 

\xfig[.8]{ArrowLp}{Schematic representation of loop}{figure:loop}


% TODO 

\begin{itemize}
  \item arrows sind getupelt
\end{itemize}



\section{First Approach: Classical Arrows}
Within this section, we present a basic cycle redundancy check implementation with the design method of arrows. The example shows a typical
way to express hardware with the functional method and also the flexibility of a functional approach is demonstrated. This is done by
implementing multiple CRC's with differing polynomials. How to generate netlists out of the functional data structure is shown later on.
After that, the problems with classical arrows are highlighted and solutions are discussed.


\subsection{Implementation}
The calculation of a specific CRC to some input data is based upon a mathematical method called a polynomial division. The reminder of that
devision is the CRC Checksum. The original data padded by the CRC results in 0 if that devision is done again. 

\par
First of all there are operators, that are essential to work with this classical arrows, because of their tuple like inner structure. This
means, that each circuit is processing only a few inputs to output. The inputs therefore need to be reordered previous to each function
call. One function, that is responsible for this tupel'ing process is \hs{mvRight}. This function takes an argument of the structure
\((x,(y,z))\) to a different structure \((y,(x,z))\). 

\begin{haskell}
mvRight :: (Arrow a) => Grid a (my, (b, rst)) (b, (my, rst))
mvRight 
  =   aDistr
  >>> first aSnd
\end{haskell} 

The first arrow that is invoked here is \hs{aDistr} which is the pendant of the distribution law. \hs{aDistr} takes something of structure
\(x, (y, z)\) into something of structure \((x, y), (x, z))\), it distributes the first element over the second one. That arrow is combined
with another one, namely \hs{first aSnd}. In fact, this really is an arrow \hs{aSnd} with a scoop-operator \hs{first} such that \hs{aSnd}
works only on the first element of the tuple. The resulting arrow takes a structure \(((x_1,x_2), (y_1,y_2))\) to a resulting structure
\((x_2, (y_1, y_2))\). In the end the \hs{mvRight} arrow moves the first element of the tuple one step to the right. Of curse this function
assumes a structure where always the first element of a tuple is a value, the second is another tuple such like: \((v_1, (v_2, (v_3, (v_4,
v_5, (\dots)))))\)


\par
Another common task over these list like tuple structure is to apply one arrow to the front and than concentrate with the remaining arrows
on the remaining structure. For this purpose the operator \hs{>:>} helps to clarify the 
\begin{haskell}
  aA >:> aB = aA >>> (second aB)
\end{haskell} 

The operator \hs{>:>} is based on the \hs{>>>} operator with a minor difference. The first supplied arrow is executed over the whole input
data tuple, while the second arrow is only applied to the second part of that tuple. Such an operator comes handy while list like tuple
structures are used and are processed from the left to the right. This is exactly the case for the polynomial division. 


\par
While working with tuple lists, it is often convenient to just reorder the parenthesis around the data so that the selector functions like
\hs{first} result in just the right behavior. Two arrows are mentioned here that exploit the associativity of arrows, namely \hs{a\_aBC2ABc}
and \hs{a\_ABc2aBC}. The somewhat cryptographic names only mirror the changing parenthesis, upper case letters show the two positions that
are enclosed by the brackets, the lower case letter is the isolated position. 
\begin{align*}
  \text{a\_aBC2ABc} &: (a, (b, c)) \rightarrow ((a, b), c) \\
  \text{a\_ABc2aBC} &: ((a, b), c) \rightarrow (a, (b, c))
\end{align*}


\par
The \hs{toInner} function makes use of the previously defined operators. There are several \hs{toInner} functions, that only differ in the
amount of steps the value is pushed into the list like tuple.
\begin{haskell}
toInner5
  =   mvRight
  >:> mvRight
  >:> mvRight
  >:> mvRight
  >:> aFlip
\end{haskell} 


\par
With \hs{crc\_checksum\_8} a higher order function is defined that abstracts the general principle behind an 8 bit CRC sum function.  
\begin{haskell}
crc_checksum_8 crc_polynom polySkip padding start rest
  =   (padding &&& aId)
  >>> toInner8

  >>> (start &&& rest)
  >>> first (crc_polynom)

  >>> step
  >>> step
  >>> step
  >>> step
  >>> step
  >>> step

  >>> aFlip
  >>> polySkip
  >>> crc_polynom

  where step =   a_aBC2ABc
             >>> first 
                 (   aFlip
                 >>> polySkip
                 >>> crc_polynom
                 )   
\end{haskell} 

Before starting to calculate the CRC, the input data need to be properly aligned. Therefore the padding bits, which are all $0$ for the
calculation of the CRC, are ``moved'' to right end of the tuple list which for any 8 bit wide CRC algorithm is done via the \hs{toInner8}.
\[((p_0, p_1), (b_0, (b_1, (b_2, (b_3, b_4))))) \rightarrow (b_0, (b_1, (b_2, (b_3, (b_4, (p_0, p_1))))))\]

\par
Afterwards the arrow actually abstracts the steps to be done to calculate a 8 bit CRC sum. The combined action \hs{(start &&& rest)} splits
the input data stream into the just enough bits that fill the Galois type shift register (the \hs{start} part) and into the remaining bits
(the \hs{rest} part). Keep in mind that the \hs{&&&} operator first duplicates its input and passes each arrow one copy. The starting bits
are then fed into the shift register via the \hs{first (crc\_polynom)} expression. Step by step all the bits are consumed, $1$ bit for every
\hs{step}. The last step is executed without the need of the \hs{first} selector, because there are no reminding bits left and for that
reason the arrow ends with the \hs{aFlip >>> polySkip >>> crc\_polynom} expression. 


\subsection{Simple Example}
There are lots of CRC-Codes out there and every one is equipped with a polynomial that especially fits the needs of its domain. In this
examples the simple CRC-Codes for USB and CCIT are shown. Their polynomials are:
\begin{align*}
  \text{USB} &: x^5 + x^2 + 1 \\
  \text{CCIT}&: x^4 + x   + 1 
\end{align*}

These polynomials describe at which positions the input bit is \hs{xor}'ed with that bit that has traveled all the way through the shift
register. For the USB CRC $\text{bit}_0$ and $\text{bit}_2$ are \hs{xor}'ed with $\text{bit}_5$, for the CCIT CRC the $\text{bit}_0$ and
$\text{bit}_1$ are \hs{xor}'ed with $\text{bit}_4$. 

\begin{figure}
  \centering
  \graphicspath{{./}{Images/}}
  \mbox{%
    \subfigure[USB CRC]{\scalebox{0.5}{\input{./Images/CRC-USB}}} \quad \quad \quad \quad
    \subfigure[CCIT CRC]{\scalebox{0.5}{\input{./Images/CRC-CCIT}}}
  }
\end{figure}


\par
The question is, what \hs{polySkip}, \hs{crc\_polynom}, \hs{padding}, \hs{start} and \hs{rest} values need to be chosen. To summarize this
for the CCIT CRC, the highest exponent is $4$. This means, that:
\begin{itemize}
  \item the \hs{polySkip} needs to be \hs{toInner4}
  \item there are $4$ \hs{padding} bits \hs{aConst (False, (False, (False, False)))} 
  \item the split between \hs{start} and \hs{rest} is after bit $4$
\end{itemize}

So the resulting definition of the CCIT CRC sum is:
\begin{haskell}
crc_checksum_ccit_8 
  :: Arrow a => Grid a 
    (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, Bool))))))) 
    (Bool, (Bool, (Bool, Bool)))
crc_checksum_ccit_8
  = crc_checksum_8   
      crc_polynom_ccit
      toInner4
      (aConst (False, (False, (False, False))))
      (second.second.second.second $ aFst)
      (aSnd >>> aSnd >>> aSnd >>> aSnd >>> aSnd)
\end{haskell} 

\subsection{Building Netlists}
The data type of the previous CRC function denotes a \hs{Graph} arrow. This is because the arrow generates a graph which in fact holds all
the information that are needed to generate netlists out of it. Basically a graph could be seen as a different form of a Netlist. In Haskell
a graph is modeled by two lists, one for the nodes and one for the edges.

\par
Every hardware component is identified by an ID that is represented by an integer value. This holds also for the in and output pins of
hardware components. The Pins also have IDs that are identified by an integer value.
\begin{haskell}
type CompID = Int
type PinID  = Int
type Pins   = [PinID]
\end{haskell}

\par
An edge represents a wire between two pins on different components and is identified by the tuple of \hs{CompID} and \hs{PinID} which is
called an \hs{AnchorPoint}. There are also two different anchor points, one that goes into a component called \hs{SinkAnchor} as well as one
that comes from a component, the \hs{SourceAnchor}. 

\begin{haskell}
type AnchorPoint  = (Maybe CompID, PinID)
type SinkAnchor   = AnchorPoint
type SourceAnchor = AnchorPoint
\end{haskell}

Note that the \hs{Maybe} constructor is used here, because there can be edges / wires from and to nowhere. These represent the edges of a
component which are not yet connected to the outside world. This by the way maps also to the real world, where it is normal, that
components which are not yet placed have pins from and to nowhere. 

\par
An edge is a wire, is a connection between two components or to be more precise, it is a connection between two anchor points. 
\begin{haskell}
data Edge 
  = MkEdge { sourceInfo :: SourceAnchor
           , sinkInfo   :: SinkAnchor }
\end{haskell}
The record notation is used, to obtain accessor functions (\hs{sourceInfo} and \hs{sinkInfo}) within one step. 

\par 
Last but not least the actual graph is defined. It holds the information about the node which is similar to the component. The name is later
used in the VHDL generation to identify the entities. Every node holds a list of sub nodes that represent from what this node is build and
helps to build up complex structures from basic simple building blocks. It also holds a list of the connected edges, as well as the list of
input- and output pins. Accessor function are also gained through the use of the record notation.
\begin{haskell}
data StructGraph
  = MkSG { name    :: String
         , compID  :: CompID
         , nodes   :: [StructGraph]
         , edges   :: [Edge]
         , sinks   :: Pins
         , sources :: Pins }   
\end{haskell}

\subsection{Problems with this approach}
This approach comes with various problems. 

As the CRC example showed, all the input data to these hardware components must fit into simple tuples. This is easy to handle if the
components only come with one or two pins and certainly that is the case for simple boolean logic gates. But at the latest if the modeled
hardware component uses more than two pins, different data structures are needed. Up to a certain amount one can simulate something similar
to lists with only tuples as is done in the CRC examples. But the simulation comes at a cost. There is a lot of restructuring the tuples in
the code going on and the CRC example only is a $8$ bit example. This process becomes more tedious, confusing and error prone, if something
like 32 bit hardware components should be modeled. And in fact hardware components with more than two in or output pins is more or less the
default case; two or less in or output pins are the exception.

\par
The tedious tuple code could at least be superficially avoided by the use of Patterson's proc-notation for arrows.
\cite{PatersonNewNotation} The proc-Notation abstracts the tuples in that way, that the hardware is described more ``visually'' in the
source code. Underneath there are still tuples in use but the developer must not be aware of them because they are automatically generated.
Here is a short example, the CCIT CRC polynomial would not only be less tedious, look much more understandable described in proc-notation. 
\begin{haskell}
crc_polynom_ccit 
 = proc (b4, (b3, (b2, (b1, b0)))) -> do
     b4' <- aId  -< (b3)
     b3' <- aId  -< (b2)
     b2' <- aXor -< (b4, b1)
     b1' <- aXor -< (b4, b0)
     returnA     -< (b4', (b3', (b2', b1')))
\end{haskell} 

\par
But there is also a problem with the notation that comes from the auto generated arrow code. Patterson's notation makes a lot use of the
\hs{arr} function of an arrow. But because it is possible to ``lift'' any function that is passed to \hs{arr} into an arrow, it is
impossible to keep track of the types of that functions. Nevertheless the type of the passed function is needed to generate a \hs{Grid}
arrow, that can be transformed into Netlists later. That is, because there is a direct correspondence between the data type of a function
and their hardware representation (e.g.\ number of in- output pins).

\subsection{Grid-Arrow}
To keep track of the defined hardware a datatype is needed. That datatype is called \hs{Grid}.
\begin{haskell}
  newtype Grid a b c = GR (a b c, CircuitDescriptor)
\end{haskell} 
The \hs{Grid} type is a combination of the executable arrow and the hardware component part. The arrow resides in the first part of the
tuple, while the hardware graph occupies the second part. A Grid can be imagined as the surface where you combine different hardware
elements with each other. In a way this is analog to the snap circuit toys from childhood. The \hs{Grid} is not only the surface to combine
hardware components, it also is recursive so that it could be used as hardware component itself. So \hs{Grid} is an arrow on its own. 

\subsection{Circuit-Descriptor}
A \hs{CircuitDescriptor} is the datatype that describes a hardware component in such a way, that a Netlist could be generated out of it. The
circuit descriptor 

%\par
%Der \hsSource{NodeDescriptor} taucht in der Definition eines Schaltkreises, aber auch in der Definition eines Registers, auf.
%
%\begin{code}
%  data CircuitDescriptor
%    = MkCombinatorial
%      { nodeDesc :: NodeDescriptor
%      , nodes    :: [CircuitDescriptor]
%      , edges    :: [Edge]
%      , cycles   :: Tick
%      , space    :: Area
%      }
%
%    | MkRegister
%      { nodeDesc :: NodeDescriptor
%      , bit      :: Int
%      }
%
%    | MkLoop
%      { nodeDesc :: NodeDescriptor
%      , nodes    :: [CircuitDescriptor]
%      , edges    :: [Edge]
%      , cycles   :: Tick
%      , space    :: Area
%      }
%
%--  | MkComposite
%
%    | NoDescriptor
%    deriving (Eq)
%
%  type Netlist = CircuitDescriptor
%\end{code}
%
%In Haskell lassen sich die Komponenten Attribute über einen Summentyp abgebildet. Dieser Datentyp ist ein fundamentaler Datentyp, da er
%gleichberechtigt neben der eigentlichen Funktionalität steht. Er besitzt einen Bezeichner \hsSource{label}, sowie eine eindeutige ID
%\hsSource{nodeId}. Zusätzlicher sind die Ein- sowie die Ausgehenden Pins aufgeführt und auch die verbindenden Kanten (\hsSource{edges}).
%
%\par 
%Jede Komponente kann durch untergeordnete Komponenten beschrieben werden. Dies wird im Datentyp über die \hsSource{nodes} Liste abgebildet.
%Ist die Komponenten atomar, so enthält dieses Datum die leere Liste. Der Konstruktor \hsSource{NoSG} ist analog zu $\varnothing$. %%% TODO : Mathematisch erklären warum {} benötigt wird
%
%\par
%Um zu verhindern, dass ungültige Schaltungsbeschreibungen erzeugt werden, können \begriff{smart constructor}s eingesetzt werden. Hierbei
%handelt es sich um Funktionen, die analog zu den Konstruktoren arbeiten. Diese unterscheiden sich darin, dass die Konstruktoren jedes Datum
%erzeugen. Allerdings ist es häufig nicht gewünscht, jedes Datum erzeugen zu können oder es ist gewünscht, dass der Benutzer beim Versuch ein
%falsches Datum zu erzeugen, mit einer Fehlermeldung konfrontiert wird. 
%
%Jede Hardware Komponente besitzt Pins verschiedener Art, darunter ein- und ausgehende. Diese sind durchnummeriert und werden über ihre
%Nummer, die als Integer abgebildet wird, identifiziert. Für die Komponenten ID gilt dies ebenfalls.
%Daneben wird der Typ für einen \begriff{Clock-Cycle} definiert. In diesem Fall wird ein Integer dafür verwendet. Auch die Fläche wird mit
%einem Integer beschrieben. Für die Fläche besagt der Wert, wieviele \begriff{Zellen} der Baustein belegt. %%% TODO : Was ist eine Zelle?
%\begin{code}
%  type PinID = Int
%  type Pins  = [PinID]
%
%  type ID     = Int
%  type CompID = ID
%
%  type Tick   = Int
%  type Area   = Int
%\end{code}
%
%\par
%Eine Kante ist eine Verbindung zwischen zwei \hsSource{Pins}, dabei müssen die beiden \hsSource{Pins} nicht unbedingt zu unterschiedlichen
%Komponenten gehören \footnote{Beispielsweise bei zyklischen Schaltungen}. Das Tupel aus \hsSource{PinID} und \hsSource{CompID} identifiziert
%einen Pin. Da auch Kanten abgebildet werden sollen, die nach außerhalb der aktuellen Komponente gehen sollen, ist es notwendig, die
%\hsSource{CompID} als \hsSource{Maybe} Typ zu beschreiben. Das Tupel wird im folgenden mit \hsSource{Anchor} bezeichnet.
%\begin{code}
%  type Anchor       = (Maybe CompID, PinID)
%  type SinkAnchor   = Anchor
%  type SourceAnchor = Anchor
%\end{code}
%
%Außerdem wurden noch zwei weitere Aliasse vergeben, die Eingehende (\hsSource{SinkAnchor}) und Ausgehende (\hsSource{SourceAnchor}) Pins
%voneinander unterscheiden.
%
%\subsection{Benannte Typen}
%Um die Graph-Struktur später in Sourcecode überführen zu können, benötigt man Namen für \hsSource{Anchor} und \hsSource{Edges} sowie
%Lookup-Tabellen, in denen dann die Namen abgelegt werden. Die Typaliasse hierfür werden hier direkt definiert.
%\begin{code}
%  type NamedPins = [(String, Anchor)]
%  type NamedSigs = [(String, Edge)]
%  type NamedSnks = NamedPins
%  type NamedSrcs = NamedPins
%  type NamedIOs  = (NamedSnks, NamedSrcs)
%
%  nameSig = "i"
%  nameExI = "inc"
%  nameExO = "out"
%  nameInI = "e"
%  nameInO = "a"
%\end{code}
%
%
%\subsection{Schaltungsbeschreibung}
%Jede Komponente die durch einen Arrow repräsentiert wird, hat zusätzliche Attribute, die nicht in dem Arrow selber stehen. Diese Attribute
%werden auch nicht für alle Arrow-Klassen Instanzen benötigt. Daher sind diese lose an den Arrow gekoppelt. \footnote{Arrow und Attribute
%werden in einem Tupel zusammengefasst}
%
%%%% TODO : is Circuit the right name? Component is better or: Chip / Device / Module / what ever
%%%% TODO : MkSG und NoSG sind die falschen Konstruktoren
%
%
%
%\subsection{Pins}
%Zunächst werden grundlegende Typaliasse vergeben, die im gesamten Quelltext Anwendung finden. 
%
%\par
%Jede Hardware Komponente besitzt Pins verschiedener Art, darunter Eingabe- und Ausgabepins.
%
%\subsection{Schaltungsbeschreibung}
%Jede Komponente die durch einen Arrow repräsentiert wird, hat zusätzliche Attribute, die nicht in dem Arrow selber stehen. Diese Attribute
%werden auch nicht für alle Arrow-Klassen Instanzen benötigt. Daher sind diese lose an den Arrow gekoppelt. \footnote{Arrow und Attribute
%werden in einem Tupel zusammengefasst}
%
%\par
%Hier wird unterschieden zwischen Kombinatorischen Schaltungen \hsSource{MkCombinatorial}, Registern \hsSource{MkRegister} und nicht
%vorhandenen Schaltungen \hsSource{NoDescriptor}. %%% TODO : Wie fließt hier MkComposite rein?
%
%\par
%Ein Register unterscheidet sich von einer kombinatorischen Schaltung, teilweise gibt es Gemeinsamkeiten. Diese Gemeinsamkeiten werden über
%den Datentyp \hsSource{NodeDescriptor} verkörpert.
%
%
%\begin{code}
%  data NodeDescriptor
%    = MkNode
%      { label   :: String 
%      , nodeId  :: ID
%      , sinks   :: Pins
%      , sources :: Pins
%      }
%    deriving (Eq)
%\end{code} 
%
%
%\par
%Es folgt der Quellcode des \begriff{smart constructor}s für ein Register. Hierbei ist nur darauf zu achten, dass dieses Register keine ID
%bekommt, die schon einmal vergeben wurde.
%
%%%% TODO : error checking muss hier noch rein
%
%\begin{code}
%  mkRegister :: NodeDescriptor -> CircuitDescriptor
%  mkRegister nd 
%    = MkRegister  
%      { nodeDesc = nd { label = "REG" ++ (show $ nodeId nd) } 
%      , bit      = length $ sinks nd
%      }
%\end{code} 
%
%
%\subsection{Kanten}
%Zuletzt fehlt jetzt lediglich die Definition einer Kante. Eine Kante kennt einen Quell-Pin sowie einen Ziel-Pin.
%\begin{code}
%  data Edge
%    = MkEdge { sourceInfo :: SourceAnchor
%             , sinkInfo   :: SinkAnchor
%             }
%    deriving (Eq)
%\end{code}
%
%
%\subsection{Smarte Konstruktoren}
%In Haskell lassen sich Typen sehr fein granular definieren. Für die Liste der Pins einer Schaltung passt eine Liste von Integer-Werten sehr
%gut aber nicht perfekt. So gibt es auch Integer-Listen mit keinem Inhalt. Wollte man das auf der Typebene verhindern, so würde dies einen
%Overhead erfordern, der nicht im Verhältnis zu dem Nutzen stehen würde. Eine einfache aber nützliche Alternative sind \begriff{smart
%constructor}. Hierbei handelt es sich um einen Funktion, die als Parameter alle Werte bekommt, die benötigt werden, um ein Datum des
%gewünschten Types zu erzeugen. Die Funktion erzeugt dann ein solches Datum und kann sich daneben auch noch um Fehler-Behandlungen kümmern.
%%%% TODO : Boxed Types reference
%
%\par
%Bei \hsSource{mkPins} handelt es sich um so einen \begriff{smart Constructor}. Dieser erhält die Anzahl der benötigten Pins als Parameter
%und erzeugt dann eine entsprechende Liste. 
%
%\begin{code}
%  mkPins :: Int -> Pins
%  mkPins 0 = error $ show "It is not possible to generate a component with 0 pins"
%  mkPins n = [0..n-1]
%\end{code}


\section{Coping with the Tupel-Problem - ``Vector-Arrows''}
So classical arrows are an adequate abstract form to describe hardware, they are modular and the come with a enhanced type system that
helps to reduce errors. The problem with them is the way the model hardware on a crucial point, namely the in- and output paths to each
component. 

\par
As stated earlier, hardware components come most of the time with $>2$ in- output pins. Also the signal types that are transported via the
interconnections between hardware is pretty limited. Most of the time there are only boolean values transmitted. Integer values are
transmitted by bundling multiple boolean ones. Sensor developers tend to digitize pretty early in their design. \cite{MakinwaSmatSensors}

\par
These properties describe hardware as something, that is static in their type of values that are exchanged and is also dynamic in their
amount of values that are exchanged. Arrows on the other hand are dynamic in the type of values that could be exchanged but are static in
their amount of single in- outputs. 

\par
The question is, can one describe a different kind of arrows, that match hardware at that point more naturally, without loosing the other
beneficial properties for hardware design. 

\par
The obvious solution is to replace the product\footnote{the tuple} in the arrow structure with a vector. Vectors are - like hardware -
static in their data type and are dynamic in their value count. To outline the idea the following pseudo code example sketches a vector
arrow type class in a Haskell syntax.
\begin{haskell}
class VArrow a where
  arrV   :: (Vec j b ->  Vec k b) -> a (Vec j b) (Vec k b)
  (>V>)  :: a (Vec k b) (Vec l b) -> a (Vec j b) (Vec k b) -> a (Vec j b) (Vec l b)
  firsts :: a (Vec j b) (Vec k b) -> a (Vec l b) (Vec m b)
  (&V&)  :: a (Vec j b) (Vec k b) -> a (Vec j b) (Vec l b) -> a (Vec j b) (Vec m b)
  (*V*)  :: a (Vec j b) (Vec k b) -> a (Vec l b) (Vec m b) -> a (Vec n b) (Vec o b)
\end{haskell}


\subsection{Vector-Arrows are not Arrows}

\subsection{Horn-Clause-Solution}

\subsection{Type-Family-Solutions}

-  :+: and :-:
- \ldots

Conclusion: That is dependent typing and Haskell is not (yet) a dependently typed function programming laguage. And all
in all it seems that the Vec-Type together with the Arrows-Instances is too much dependent typing for Haskell

\subsection{Using a dependently types language}

\section{Copeing with \hs{arr}-Problem}

\subsection{ForSyDe: Using the AST of the arr argument}

In order to transform a usual Haskell function into an hardware block, ForSyDe stores the AST of that function which is
used later to synthesis VHDL.  \subsection{Show-Type-Class (or Typeable)}

\subsection{Generalized Arrows -- avoiding arr}


\bibliographystyle{plain}
\bibliography{Bibliography}
\end{document}
